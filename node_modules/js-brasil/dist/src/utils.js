"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var estados_1 = require("./estados");
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isArray(value) {
    return (Array.isArray && Array.isArray(value)) || value instanceof Array;
}
exports.isArray = isArray;
function isString(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.isString = isString;
function isNumber(value) {
    return typeof value === 'number' && !isNaN(value); // && value.length === undefined
}
exports.isNumber = isNumber;
function isNil(value) {
    return typeof value === 'undefined' || value === null;
}
exports.isNil = isNil;
var strCaretTrap = '[]';
function processCaretTraps(mask) {
    var indexes = [];
    var indexOfCaretTrap;
    while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) { // eslint-disable-line
        indexes.push(indexOfCaretTrap);
        mask.splice(indexOfCaretTrap, 1);
    }
    return { maskWithoutCaretTraps: mask, indexes: indexes };
}
exports.processCaretTraps = processCaretTraps;
exports.modulo11 = function (string, size, mod) {
    var soma = 0;
    for (var i = 1; i <= size; i++) {
        // tslint:disable-next-line:radix
        soma = soma + parseInt(string.substring(i - 1, i)) * (mod - i);
    }
    var resto = (soma * 10) % 11;
    if ((resto === 10) || (resto === 11)) {
        resto = 0;
    }
    return resto;
};
/**
 *
 * @param input
 * ^ - Match line start
  (\d) - match first digit and capture it in back reference #1 i.e. \1
  (?!..) is a negative lookahead
  (?!\1+$) means disallow the match if first digit is followed by same digit (captured group) till end.
  \d{11}$ match next 11 digit followed by line end
 */
function allNumbersAreSame(inputValue) {
    var input = getAllDigits(inputValue);
    if (typeof input === 'string') {
        var reg = new RegExp('^(\\d)(?!\\1+$)\\d{' + (input.length - 1) + '}$');
        return reg.test(input);
    }
    return false;
}
exports.allNumbersAreSame = allNumbersAreSame;
function getAllDigits(input) {
    if (!input.match) {
        input = input.toString();
    }
    var match = input.match(/\d/g);
    if (match) {
        return match.join("");
    }
    return '';
}
exports.getAllDigits = getAllDigits;
function getAllWords(input) {
    var match = input.match(/\w/g);
    if (match) {
        return match.join("");
    }
    return '';
}
exports.getAllWords = getAllWords;
function currencyToNumber(input) {
    input = input.replace(/ /g, '');
    if (input.indexOf('$') !== -1) {
        var vals = input.split('$');
        input = vals[1];
    }
    input = input.replace('%', '');
    input = input.replace(/\./g, '').replace(',', '.');
    return parseFloat(input);
}
exports.currencyToNumber = currencyToNumber;
function slugify(value) {
    return value.toString().toLowerCase()
        .replace(/[àÀáÁâÂãäÄÅåª]+/g, 'a') // Special Characters #1
        .replace(/[èÈéÉêÊëË]+/g, 'e') // Special Characters #2
        .replace(/[ìÌíÍîÎïÏ]+/g, 'i') // Special Characters #3
        .replace(/[òÒóÓôÔõÕöÖº]+/g, 'o') // Special Characters #4
        .replace(/[ùÙúÚûÛüÜ]+/g, 'u') // Special Characters #5
        .replace(/[ýÝÿŸ]+/g, 'y') // Special Characters #6
        .replace(/[ñÑ]+/g, 'n') // Special Characters #7
        .replace(/[çÇ]+/g, 'c') // Special Characters #8
        .replace(/[ß]+/g, 'ss') // Special Characters #9
        .replace(/[Ææ]+/g, 'ae') // Special Characters #10
        .replace(/[Øøœ]+/g, 'oe') // Special Characters #11
        .replace(/[%]+/g, 'pct') // Special Characters #12
        .replace(/\s+/g, '-') // Replace spaces with -
        .replace(/[^\w\-]+/g, '') // Remove all non-word chars
        .replace(/\-\-+/g, '-') // Replace multiple - with single -
        .replace(/^-+/, '') // Trim - from start of text
        .replace(/-+$/, ''); // Trim - from end of text
}
exports.slugify = slugify;
;
/**
 *
 * @param string  ex. 12345
 * @param size   11
 * @param fill   0
 *
 * Returns: 00000012345
 */
function fillString(string, size, fill) {
    if (string.size < size) {
        var dif = size - string.size;
        for (var i = 0; i < dif; i++) {
            string = fill + string;
        }
    }
    return string;
}
exports.fillString = fillString;
function randArray(array) {
    var index = randomNumber(0, array.length);
    return array[index];
}
exports.randArray = randArray;
function rand(length) {
    var ranges = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        ranges[_i - 1] = arguments[_i];
    }
    var str = ""; // the string (initialized to "")
    while (length--) { // repeat this length of times
        var ind = Math.floor(Math.random() * ranges.length); // get a random range from the ranges object
        var min = ranges[ind][0].charCodeAt(0), // get the minimum char code allowed for this range
        max = ranges[ind][1].charCodeAt(0); // get the maximum char code allowed for this range
        var c = Math.floor(Math.random() * (max - min + 1)) + min; // get a random char code between min and max
        str += String.fromCharCode(c); // convert it back into a character and append it to the string str
    }
    return str; // return str
}
exports.rand = rand;
function randomNumber(begin, end) {
    var dif = end - begin;
    var number = Math.floor(Math.random() * dif) + begin;
    return number;
}
exports.randomNumber = randomNumber;
function randomLetter(size, onlyCapitals) {
    if (size === void 0) { size = 1; }
    if (onlyCapitals === void 0) { onlyCapitals = false; }
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    if (onlyCapitals == false) {
        possible += "abcdefghijklmnopqrstuvwxyz";
    }
    possible = possible.split('');
    for (var i = 0; i < size; i++) {
        var pos = Math.floor(Math.random() * possible.length);
        text += possible[pos];
    }
    return text;
}
exports.randomLetter = randomLetter;
function randomLetterOrNumber(size, onlyCapitals) {
    if (size === void 0) { size = 1; }
    if (onlyCapitals === void 0) { onlyCapitals = false; }
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    if (onlyCapitals == false) {
        possible += "abcdefghijklmnopqrstuvwxyz0123456789";
    }
    possible = possible.split('');
    for (var i = 0; i < size; i++) {
        var pos = Math.floor(Math.random() * possible.length);
        text += possible[pos];
    }
    return text;
}
exports.randomLetterOrNumber = randomLetterOrNumber;
exports.randomEstadoSigla = function () {
    var total = estados_1.ESTADOS_SIGLA.length;
    return estados_1.ESTADOS_SIGLA[Math.floor(Math.random() * total)];
};
exports.CORES = ["AMARELO", "AZUL", "BEGE", "BRANCA", "CINZA", "DOURADA", "GRENA", "LARANJA", "MARROM", "PRATA",
    "PRETA", "ROSA", "ROXA", "VERDE", "VERMELHA", "FANTASIA"];
/**
 *
 */
exports.makeGenericFaker = function (val, options) {
    if (options === void 0) { options = null; }
    return function () {
        if (!val.textMask || !val.textMask.map) {
            return '';
        }
        var newData = val.textMask.map(function (c, index) {
            if (options && options[index]) {
                return options[index]();
            }
            c = c.toString();
            if (c === /\d/.toString()) {
                return Math.floor(Math.random() * 10).toString();
            }
            else if (c === /[A-Za-z]/.toString()) {
                return randomLetter(1).toString();
            }
            else if (c === /\w/.toString()) {
                return randomLetterOrNumber(1).toString();
            }
            else if (c.indexOf('/[') === 0) { // /[1-9]/ ou /[5-9]/
                c = c.replace('/[', '').replace(']/', '');
                if (c.indexOf('-') > 0) {
                    c = c.split('-');
                    if (parseInt(c[1])) {
                        var mult = c[1] - c[0];
                        var plus = parseInt(c[0]);
                        return (Math.floor(Math.random() * mult) + plus).toString();
                    }
                    else {
                        return rand(1, [c[0], c[1]]);
                    }
                }
                else if (c.indexOf('|') > 0) {
                    c = c.split('|');
                    var index_1 = Math.floor(Math.random() * c.length);
                    return c[index_1];
                }
            }
            else {
                return c;
            }
        });
        return newData.join('');
    };
};
//# sourceMappingURL=utils.js.map