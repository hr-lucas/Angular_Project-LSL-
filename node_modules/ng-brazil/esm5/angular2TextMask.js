import { __decorate, __param } from "tslib";
import { Directive, ElementRef, forwardRef, Input, Inject, NgModule, OnChanges, Optional, Provider, SimpleChanges, Injectable, RendererFactory2 } from '@angular/core';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { ÉµgetDOM as getDOM, BrowserModule } from '@angular/platform-browser';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';
var TextMaskConfig = /** @class */ (function () {
    function TextMaskConfig() {
    }
    return TextMaskConfig;
}());
export { TextMaskConfig };
export var MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return MaskedInputDirective; }),
    multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    var userAgent = getDOM() ? getDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
var MaskedInputDirective = /** @class */ (function () {
    function MaskedInputDirective(rendererFactory, _elementRef, _compositionMode) {
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = function (_) { };
        this.onTouched = function () { };
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        this._renderer = rendererFactory.createRenderer(null, null);
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    MaskedInputDirective.prototype.ngOnChanges = function (changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    };
    MaskedInputDirective.prototype.writeValue = function (value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        var normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    };
    MaskedInputDirective.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    MaskedInputDirective.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    MaskedInputDirective.prototype.setDisabledState = function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    MaskedInputDirective.prototype._handleInput = function (value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    };
    MaskedInputDirective.prototype._setupMask = function (create) {
        if (create === void 0) { create = false; }
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    };
    MaskedInputDirective.prototype._compositionStart = function () { this._composing = true; };
    MaskedInputDirective.prototype._compositionEnd = function (value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    };
    MaskedInputDirective.ctorParameters = function () { return [
        { type: RendererFactory2 },
        { type: ElementRef },
        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
    ]; };
    __decorate([
        Input('textMask')
    ], MaskedInputDirective.prototype, "textMaskConfig", void 0);
    MaskedInputDirective = __decorate([
        Injectable(),
        Directive({
            host: {
                '(input)': '_handleInput($event.target.value)',
                '(blur)': 'onTouched()',
                '(compositionstart)': '_compositionStart()',
                '(compositionend)': '_compositionEnd($event.target.value)'
            },
            selector: '[textMask]',
            exportAs: 'textMask',
            providers: [MASKEDINPUT_VALUE_ACCESSOR]
        }),
        __param(2, Optional()), __param(2, Inject(COMPOSITION_BUFFER_MODE))
    ], MaskedInputDirective);
    return MaskedInputDirective;
}());
export { MaskedInputDirective };
var TextMaskModule = /** @class */ (function () {
    function TextMaskModule() {
    }
    TextMaskModule = __decorate([
        NgModule({
            imports: [
                BrowserModule
            ],
            declarations: [MaskedInputDirective],
            exports: [MaskedInputDirective]
        })
    ], TextMaskModule);
    return TextMaskModule;
}());
export { TextMaskModule };
export { conformToMask } from 'text-mask-core/dist/textMaskCore';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjJUZXh0TWFzay5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWJyYXppbC8iLCJzb3VyY2VzIjpbImFuZ3VsYXIyVGV4dE1hc2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFDMUQsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFDM0UsTUFBTSxlQUFlLENBQUE7QUFDdEIsT0FBTyxFQUFFLGlCQUFpQixFQUF3Qix1QkFBdUIsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQ2pHLE9BQU8sRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFBO0FBQzVFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFBO0FBRTdFO0lBQUE7SUFPQSxDQUFDO0lBQUQscUJBQUM7QUFBRCxDQUFDLEFBUEQsSUFPQzs7QUFFRCxNQUFNLENBQUMsSUFBTSwwQkFBMEIsR0FBYTtJQUNsRCxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsY0FBTSxPQUFBLG9CQUFvQixFQUFwQixDQUFvQixDQUFDO0lBQ25ELEtBQUssRUFBRSxJQUFJO0NBQ1osQ0FBQTtBQUVEOzs7R0FHRztBQUNILFNBQVMsVUFBVTtJQUNqQixJQUFNLFNBQVMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUN6RCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUE7QUFDdEQsQ0FBQztBQWNEO0lBa0JFLDhCQUNFLGVBQWlDLEVBQ3pCLFdBQXVCLEVBQ3NCLGdCQUF5QjtRQUR0RSxn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RUFBRSxZQUFZO1lBQ3RCLFFBQVEsRUFBRSxVQUFVO1lBQ3BCLFNBQVMsRUFBRSxDQUFDLDBCQUEwQixDQUFDO1NBQ3hDLENBQUM7UUFzQkcsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUE7T0FyQm5DLG9CQUFvQixDQStGaEM7SUFBRCwyQkFBQztDQUFBLEFBL0ZELElBK0ZDO1NBL0ZZLG9CQUFvQjtBQXdHakM7SUFBQTtJQUE4QixDQUFDO0lBQWxCLGNBQWM7UUFQMUIsUUFBUSxDQUFDO1lBQ1IsT0FBTyxFQUFFO2dCQUNQLGFBQWE7YUFDZDtZQUNELFlBQVksRUFBRSxDQUFDLG9CQUFvQixDQUFDO1lBQ3BDLE9BQU8sRUFBRSxDQUFDLG9CQUFvQixDQUFDO1NBQ2hDLENBQUM7T0FDVyxjQUFjLENBQUk7SUFBRCxxQkFBQztDQUFBLEFBQS9CLElBQStCO1NBQWxCLGNBQWM7QUFFM0IsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtDQUFrQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIElucHV0LCBJbmplY3QsIE5nTW9kdWxlLFxyXG4gIE9uQ2hhbmdlcywgT3B0aW9uYWwsIFByb3ZpZGVyLCBTaW1wbGVDaGFuZ2VzLCBJbmplY3RhYmxlLCBSZW5kZXJlckZhY3RvcnkyXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSdcclxuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IsIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBDT01QT1NJVElPTl9CVUZGRVJfTU9ERSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJ1xyXG5pbXBvcnQgeyDJtWdldERPTSBhcyBnZXRET00sIEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJ1xyXG5pbXBvcnQgeyBjcmVhdGVUZXh0TWFza0lucHV0RWxlbWVudCB9IGZyb20gJ3RleHQtbWFzay1jb3JlL2Rpc3QvdGV4dE1hc2tDb3JlJ1xyXG5cclxuZXhwb3J0IGNsYXNzIFRleHRNYXNrQ29uZmlnIHtcclxuICBtYXNrOiBBcnJheTxzdHJpbmcgfCBSZWdFeHA+IHwgKChyYXc6IHN0cmluZykgPT4gQXJyYXk8c3RyaW5nIHwgUmVnRXhwPikgfCBmYWxzZVxyXG4gIGd1aWRlPzogYm9vbGVhblxyXG4gIHBsYWNlaG9sZGVyQ2hhcj86IHN0cmluZ1xyXG4gIHBpcGU/OiAoY29uZm9ybWVkVmFsdWU6IHN0cmluZywgY29uZmlnOiBUZXh0TWFza0NvbmZpZykgPT4gZmFsc2UgfCBzdHJpbmcgfCBvYmplY3RcclxuICBrZWVwQ2hhclBvc2l0aW9ucz86IGJvb2xlYW5cclxuICBzaG93TWFzaz86IGJvb2xlYW5cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE1BU0tFRElOUFVUX1ZBTFVFX0FDQ0VTU09SOiBQcm92aWRlciA9IHtcclxuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNYXNrZWRJbnB1dERpcmVjdGl2ZSksXHJcbiAgbXVsdGk6IHRydWVcclxufVxyXG5cclxuLyoqXHJcbiAqIFdlIG11c3QgY2hlY2sgd2hldGhlciB0aGUgYWdlbnQgaXMgQW5kcm9pZCBiZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50c1xyXG4gKiBiZWhhdmUgZGlmZmVyZW50bHkgYmV0d2VlbiBpT1MgYW5kIEFuZHJvaWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBfaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHVzZXJBZ2VudCA9IGdldERPTSgpID8gZ2V0RE9NKCkuZ2V0VXNlckFnZW50KCkgOiAnJ1xyXG4gIHJldHVybiAvYW5kcm9pZCAoXFxkKykvLnRlc3QodXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXHJcbn1cclxuXHJcbkBJbmplY3RhYmxlKClcclxuQERpcmVjdGl2ZSh7XHJcbiAgaG9zdDoge1xyXG4gICAgJyhpbnB1dCknOiAnX2hhbmRsZUlucHV0KCRldmVudC50YXJnZXQudmFsdWUpJyxcclxuICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknLFxyXG4gICAgJyhjb21wb3NpdGlvbnN0YXJ0KSc6ICdfY29tcG9zaXRpb25TdGFydCgpJyxcclxuICAgICcoY29tcG9zaXRpb25lbmQpJzogJ19jb21wb3NpdGlvbkVuZCgkZXZlbnQudGFyZ2V0LnZhbHVlKSdcclxuICB9LFxyXG4gIHNlbGVjdG9yOiAnW3RleHRNYXNrXScsXHJcbiAgZXhwb3J0QXM6ICd0ZXh0TWFzaycsXHJcbiAgcHJvdmlkZXJzOiBbTUFTS0VESU5QVVRfVkFMVUVfQUNDRVNTT1JdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXNrZWRJbnB1dERpcmVjdGl2ZSBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkNoYW5nZXMge1xyXG4gIEBJbnB1dCgndGV4dE1hc2snKSB0ZXh0TWFza0NvbmZpZzogVGV4dE1hc2tDb25maWcgPSB7XHJcbiAgICBtYXNrOiBbXSxcclxuICAgIGd1aWRlOiB0cnVlLFxyXG4gICAgcGxhY2Vob2xkZXJDaGFyOiAnXycsXHJcbiAgICBwaXBlOiB1bmRlZmluZWQsXHJcbiAgICBrZWVwQ2hhclBvc2l0aW9uczogZmFsc2UsXHJcbiAgfVxyXG5cclxuICBvbkNoYW5nZSA9IChfOiBhbnkpID0+IHsgfVxyXG4gIG9uVG91Y2hlZCA9ICgpID0+IHsgfVxyXG5cclxuICBwcml2YXRlIHRleHRNYXNrSW5wdXRFbGVtZW50OiBhbnlcclxuICBwcml2YXRlIGlucHV0RWxlbWVudDogSFRNTElucHV0RWxlbWVudFxyXG4gIHByaXZhdGUgX3JlbmRlcmVyOiBhbnk7XHJcbiAgLyoqIFdoZXRoZXIgdGhlIHVzZXIgaXMgY3JlYXRpbmcgYSBjb21wb3NpdGlvbiBzdHJpbmcgKElNRSBldmVudHMpLiAqL1xyXG4gIHByaXZhdGUgX2NvbXBvc2luZyA9IGZhbHNlXHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcmVuZGVyZXJGYWN0b3J5OiBSZW5kZXJlckZhY3RvcnkyLFxyXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoQ09NUE9TSVRJT05fQlVGRkVSX01PREUpIHByaXZhdGUgX2NvbXBvc2l0aW9uTW9kZTogYm9vbGVhblxyXG4gICkge1xyXG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlckZhY3RvcnkuY3JlYXRlUmVuZGVyZXIobnVsbCwgbnVsbCk7XHJcbiAgICBpZiAodGhpcy5fY29tcG9zaXRpb25Nb2RlID09IG51bGwpIHtcclxuICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlID0gIV9pc0FuZHJvaWQoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgdGhpcy5fc2V0dXBNYXNrKHRydWUpXHJcbiAgICBpZiAodGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQudXBkYXRlKHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XHJcbiAgICB0aGlzLl9zZXR1cE1hc2soKVxyXG5cclxuICAgIC8vIHNldCB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2FzZXMgd2hlcmUgdGhlIG1hc2sgaXMgZGlzYWJsZWRcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlXHJcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmlucHV0RWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKVxyXG5cclxuICAgIGlmICh0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy50ZXh0TWFza0lucHV0RWxlbWVudC51cGRhdGUodmFsdWUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoXzogYW55KSA9PiB2b2lkKTogdm9pZCB7IHRoaXMub25DaGFuZ2UgPSBmbiB9XHJcbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHsgdGhpcy5vblRvdWNoZWQgPSBmbiB9XHJcblxyXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKVxyXG4gIH1cclxuXHJcblxyXG4gIF9oYW5kbGVJbnB1dCh2YWx1ZSkge1xyXG4gICAgaWYgKCF0aGlzLl9jb21wb3NpdGlvbk1vZGUgfHwgKHRoaXMuX2NvbXBvc2l0aW9uTW9kZSAmJiAhdGhpcy5fY29tcG9zaW5nKSkge1xyXG4gICAgICB0aGlzLl9zZXR1cE1hc2soKVxyXG5cclxuICAgICAgaWYgKHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQudXBkYXRlKHZhbHVlKVxyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIHVwZGF0ZWQgdmFsdWVcclxuICAgICAgICB2YWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh2YWx1ZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3NldHVwTWFzayhjcmVhdGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKCF0aGlzLmlucHV0RWxlbWVudCkge1xyXG4gICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lOUFVUJykge1xyXG4gICAgICAgIC8vIGB0ZXh0TWFza2AgZGlyZWN0aXZlIGlzIHVzZWQgZGlyZWN0bHkgb24gYW4gaW5wdXQgZWxlbWVudFxyXG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYHRleHRNYXNrYCBkaXJlY3RpdmUgaXMgdXNlZCBvbiBhbiBhYnN0cmFjdGVkIGlucHV0IGVsZW1lbnQsIGBtZC1pbnB1dC1jb250YWluZXJgLCBldGNcclxuICAgICAgICB0aGlzLmlucHV0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSU5QVVQnKVswXVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50ICYmIGNyZWF0ZSkge1xyXG4gICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50ID0gY3JlYXRlVGV4dE1hc2tJbnB1dEVsZW1lbnQoXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7IGlucHV0RWxlbWVudDogdGhpcy5pbnB1dEVsZW1lbnQgfSwgdGhpcy50ZXh0TWFza0NvbmZpZylcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIF9jb21wb3NpdGlvblN0YXJ0KCk6IHZvaWQgeyB0aGlzLl9jb21wb3NpbmcgPSB0cnVlIH1cclxuXHJcbiAgX2NvbXBvc2l0aW9uRW5kKHZhbHVlOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2NvbXBvc2luZyA9IGZhbHNlXHJcbiAgICB0aGlzLl9jb21wb3NpdGlvbk1vZGUgJiYgdGhpcy5faGFuZGxlSW5wdXQodmFsdWUpXHJcbiAgfVxyXG59XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIEJyb3dzZXJNb2R1bGVcclxuICBdLFxyXG4gIGRlY2xhcmF0aW9uczogW01hc2tlZElucHV0RGlyZWN0aXZlXSxcclxuICBleHBvcnRzOiBbTWFza2VkSW5wdXREaXJlY3RpdmVdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUZXh0TWFza01vZHVsZSB7IH1cclxuXHJcbmV4cG9ydCB7IGNvbmZvcm1Ub01hc2sgfSBmcm9tICd0ZXh0LW1hc2stY29yZS9kaXN0L3RleHRNYXNrQ29yZSciXX0=