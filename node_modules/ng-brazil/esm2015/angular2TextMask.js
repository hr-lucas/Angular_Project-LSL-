import { __decorate, __param } from "tslib";
import { Directive, ElementRef, forwardRef, Input, Inject, NgModule, OnChanges, Optional, Provider, SimpleChanges, Injectable, RendererFactory2 } from '@angular/core';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { ÉµgetDOM as getDOM, BrowserModule } from '@angular/platform-browser';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';
export class TextMaskConfig {
}
export const MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MaskedInputDirective),
    multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    const userAgent = getDOM() ? getDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
let MaskedInputDirective = class MaskedInputDirective {
    constructor(rendererFactory, _elementRef, _compositionMode) {
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        this._renderer = rendererFactory.createRenderer(null, null);
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    ngOnChanges(changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    writeValue(value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        const normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    }
    _setupMask(create = false) {
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    }
    _compositionStart() { this._composing = true; }
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
};
MaskedInputDirective.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: ElementRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
];
__decorate([
    Input('textMask')
], MaskedInputDirective.prototype, "textMaskConfig", void 0);
MaskedInputDirective = __decorate([
    Injectable(),
    Directive({
        host: {
            '(input)': '_handleInput($event.target.value)',
            '(blur)': 'onTouched()',
            '(compositionstart)': '_compositionStart()',
            '(compositionend)': '_compositionEnd($event.target.value)'
        },
        selector: '[textMask]',
        exportAs: 'textMask',
        providers: [MASKEDINPUT_VALUE_ACCESSOR]
    }),
    __param(2, Optional()), __param(2, Inject(COMPOSITION_BUFFER_MODE))
], MaskedInputDirective);
export { MaskedInputDirective };
let TextMaskModule = class TextMaskModule {
};
TextMaskModule = __decorate([
    NgModule({
        imports: [
            BrowserModule
        ],
        declarations: [MaskedInputDirective],
        exports: [MaskedInputDirective]
    })
], TextMaskModule);
export { TextMaskModule };
export { conformToMask } from 'text-mask-core/dist/textMaskCore';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjJUZXh0TWFzay5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWJyYXppbC8iLCJzb3VyY2VzIjpbImFuZ3VsYXIyVGV4dE1hc2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFDMUQsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFDM0UsTUFBTSxlQUFlLENBQUE7QUFDdEIsT0FBTyxFQUFFLGlCQUFpQixFQUF3Qix1QkFBdUIsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQ2pHLE9BQU8sRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFBO0FBQzVFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFBO0FBRTdFLE1BQU0sT0FBTyxjQUFjO0NBTzFCO0FBRUQsTUFBTSxDQUFDLE1BQU0sMEJBQTBCLEdBQWE7SUFDbEQsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixDQUFDO0lBQ25ELEtBQUssRUFBRSxJQUFJO0NBQ1osQ0FBQTtBQUVEOzs7R0FHRztBQUNILFNBQVMsVUFBVTtJQUNqQixNQUFNLFNBQVMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUN6RCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUE7QUFDdEQsQ0FBQztBQWNELElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQW9CO0lBa0IvQixZQUNFLGVBQWlDLEVBQ3pCLFdBQXVCLEVBQ3NCLGdCQUF5QjtRQUR0RSxnQkFB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QUMsMEJBQTBCLENBQUM7S0FDeEMsQ0FBQztJQXNCRyxXQUFBLFFBQVEsRUFBRSxDQUFBLEVBQUUsV0FBQSxNQUFNLENBQUMsdUJBQXVCLENBQUMsQ0FBQTtHQXJCbkMsb0JBQW9CLENBK0ZoQztTQS9GWSxvQkFBb0I7QUF3R2pDLElBQWEsY0FBYyxHQUEzQixNQUFhLGNBQWM7Q0FBSSxDQUFBO0FBQWxCLGNBQWM7SUFQMUIsUUFBUSxDQUFDO1FBQ1IsT0FBTyxFQUFFO1lBQ1AsYUFBYTtTQUNkO1FBQ0QsWUFBWSxFQUFFLENBQUMsb0JBQW9CLENBQUM7UUFDcEMsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUM7S0FDaEMsQ0FBQztHQUNXLGNBQWMsQ0FBSTtTQUFsQixjQUFjO0FBRTNCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmLCBJbnB1dCwgSW5qZWN0LCBOZ01vZHVsZSxcclxuICBPbkNoYW5nZXMsIE9wdGlvbmFsLCBQcm92aWRlciwgU2ltcGxlQ2hhbmdlcywgSW5qZWN0YWJsZSwgUmVuZGVyZXJGYWN0b3J5MlxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnXHJcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgQ09NUE9TSVRJT05fQlVGRkVSX01PREUgfSBmcm9tICdAYW5ndWxhci9mb3JtcydcclxuaW1wb3J0IHsgybVnZXRET00gYXMgZ2V0RE9NLCBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcidcclxuaW1wb3J0IHsgY3JlYXRlVGV4dE1hc2tJbnB1dEVsZW1lbnQgfSBmcm9tICd0ZXh0LW1hc2stY29yZS9kaXN0L3RleHRNYXNrQ29yZSdcclxuXHJcbmV4cG9ydCBjbGFzcyBUZXh0TWFza0NvbmZpZyB7XHJcbiAgbWFzazogQXJyYXk8c3RyaW5nIHwgUmVnRXhwPiB8ICgocmF3OiBzdHJpbmcpID0+IEFycmF5PHN0cmluZyB8IFJlZ0V4cD4pIHwgZmFsc2VcclxuICBndWlkZT86IGJvb2xlYW5cclxuICBwbGFjZWhvbGRlckNoYXI/OiBzdHJpbmdcclxuICBwaXBlPzogKGNvbmZvcm1lZFZhbHVlOiBzdHJpbmcsIGNvbmZpZzogVGV4dE1hc2tDb25maWcpID0+IGZhbHNlIHwgc3RyaW5nIHwgb2JqZWN0XHJcbiAga2VlcENoYXJQb3NpdGlvbnM/OiBib29sZWFuXHJcbiAgc2hvd01hc2s/OiBib29sZWFuXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBNQVNLRURJTlBVVF9WQUxVRV9BQ0NFU1NPUjogUHJvdmlkZXIgPSB7XHJcbiAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWFza2VkSW5wdXREaXJlY3RpdmUpLFxyXG4gIG11bHRpOiB0cnVlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXZSBtdXN0IGNoZWNrIHdoZXRoZXIgdGhlIGFnZW50IGlzIEFuZHJvaWQgYmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHNcclxuICogYmVoYXZlIGRpZmZlcmVudGx5IGJldHdlZW4gaU9TIGFuZCBBbmRyb2lkLlxyXG4gKi9cclxuZnVuY3Rpb24gX2lzQW5kcm9pZCgpOiBib29sZWFuIHtcclxuICBjb25zdCB1c2VyQWdlbnQgPSBnZXRET00oKSA/IGdldERPTSgpLmdldFVzZXJBZ2VudCgpIDogJydcclxuICByZXR1cm4gL2FuZHJvaWQgKFxcZCspLy50ZXN0KHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxyXG59XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbkBEaXJlY3RpdmUoe1xyXG4gIGhvc3Q6IHtcclxuICAgICcoaW5wdXQpJzogJ19oYW5kbGVJbnB1dCgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXHJcbiAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyxcclxuICAgICcoY29tcG9zaXRpb25zdGFydCknOiAnX2NvbXBvc2l0aW9uU3RhcnQoKScsXHJcbiAgICAnKGNvbXBvc2l0aW9uZW5kKSc6ICdfY29tcG9zaXRpb25FbmQoJGV2ZW50LnRhcmdldC52YWx1ZSknXHJcbiAgfSxcclxuICBzZWxlY3RvcjogJ1t0ZXh0TWFza10nLFxyXG4gIGV4cG9ydEFzOiAndGV4dE1hc2snLFxyXG4gIHByb3ZpZGVyczogW01BU0tFRElOUFVUX1ZBTFVFX0FDQ0VTU09SXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFza2VkSW5wdXREaXJlY3RpdmUgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoJ3RleHRNYXNrJykgdGV4dE1hc2tDb25maWc6IFRleHRNYXNrQ29uZmlnID0ge1xyXG4gICAgbWFzazogW10sXHJcbiAgICBndWlkZTogdHJ1ZSxcclxuICAgIHBsYWNlaG9sZGVyQ2hhcjogJ18nLFxyXG4gICAgcGlwZTogdW5kZWZpbmVkLFxyXG4gICAga2VlcENoYXJQb3NpdGlvbnM6IGZhbHNlLFxyXG4gIH1cclxuXHJcbiAgb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7IH1cclxuICBvblRvdWNoZWQgPSAoKSA9PiB7IH1cclxuXHJcbiAgcHJpdmF0ZSB0ZXh0TWFza0lucHV0RWxlbWVudDogYW55XHJcbiAgcHJpdmF0ZSBpbnB1dEVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnRcclxuICBwcml2YXRlIF9yZW5kZXJlcjogYW55O1xyXG4gIC8qKiBXaGV0aGVyIHRoZSB1c2VyIGlzIGNyZWF0aW5nIGEgY29tcG9zaXRpb24gc3RyaW5nIChJTUUgZXZlbnRzKS4gKi9cclxuICBwcml2YXRlIF9jb21wb3NpbmcgPSBmYWxzZVxyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHJlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MixcclxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFKSBwcml2YXRlIF9jb21wb3NpdGlvbk1vZGU6IGJvb2xlYW5cclxuICApIHtcclxuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xyXG4gICAgaWYgKHRoaXMuX2NvbXBvc2l0aW9uTW9kZSA9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2NvbXBvc2l0aW9uTW9kZSA9ICFfaXNBbmRyb2lkKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgIHRoaXMuX3NldHVwTWFzayh0cnVlKVxyXG4gICAgaWYgKHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50LnVwZGF0ZSh0aGlzLmlucHV0RWxlbWVudC52YWx1ZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xyXG4gICAgdGhpcy5fc2V0dXBNYXNrKClcclxuXHJcbiAgICAvLyBzZXQgdGhlIGluaXRpYWwgdmFsdWUgZm9yIGNhc2VzIHdoZXJlIHRoZSBtYXNrIGlzIGRpc2FibGVkXHJcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZVxyXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dEVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSlcclxuXHJcbiAgICBpZiAodGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQudXBkYXRlKHZhbHVlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQgeyB0aGlzLm9uQ2hhbmdlID0gZm4gfVxyXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7IHRoaXMub25Ub3VjaGVkID0gZm4gfVxyXG5cclxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZClcclxuICB9XHJcblxyXG5cclxuICBfaGFuZGxlSW5wdXQodmFsdWUpIHtcclxuICAgIGlmICghdGhpcy5fY29tcG9zaXRpb25Nb2RlIHx8ICh0aGlzLl9jb21wb3NpdGlvbk1vZGUgJiYgIXRoaXMuX2NvbXBvc2luZykpIHtcclxuICAgICAgdGhpcy5fc2V0dXBNYXNrKClcclxuXHJcbiAgICAgIGlmICh0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50LnVwZGF0ZSh2YWx1ZSlcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSB1cGRhdGVkIHZhbHVlXHJcbiAgICAgICAgdmFsdWUgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZVxyXG4gICAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9zZXR1cE1hc2soY3JlYXRlID0gZmFsc2UpIHtcclxuICAgIGlmICghdGhpcy5pbnB1dEVsZW1lbnQpIHtcclxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTlBVVCcpIHtcclxuICAgICAgICAvLyBgdGV4dE1hc2tgIGRpcmVjdGl2ZSBpcyB1c2VkIGRpcmVjdGx5IG9uIGFuIGlucHV0IGVsZW1lbnRcclxuICAgICAgICB0aGlzLmlucHV0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGB0ZXh0TWFza2AgZGlyZWN0aXZlIGlzIHVzZWQgb24gYW4gYWJzdHJhY3RlZCBpbnB1dCBlbGVtZW50LCBgbWQtaW5wdXQtY29udGFpbmVyYCwgZXRjXHJcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlucHV0RWxlbWVudCAmJiBjcmVhdGUpIHtcclxuICAgICAgdGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCA9IGNyZWF0ZVRleHRNYXNrSW5wdXRFbGVtZW50KFxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oeyBpbnB1dEVsZW1lbnQ6IHRoaXMuaW5wdXRFbGVtZW50IH0sIHRoaXMudGV4dE1hc2tDb25maWcpXHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICBfY29tcG9zaXRpb25TdGFydCgpOiB2b2lkIHsgdGhpcy5fY29tcG9zaW5nID0gdHJ1ZSB9XHJcblxyXG4gIF9jb21wb3NpdGlvbkVuZCh2YWx1ZTogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZVxyXG4gICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlICYmIHRoaXMuX2hhbmRsZUlucHV0KHZhbHVlKVxyXG4gIH1cclxufVxyXG5cclxuQE5nTW9kdWxlKHtcclxuICBpbXBvcnRzOiBbXHJcbiAgICBCcm93c2VyTW9kdWxlXHJcbiAgXSxcclxuICBkZWNsYXJhdGlvbnM6IFtNYXNrZWRJbnB1dERpcmVjdGl2ZV0sXHJcbiAgZXhwb3J0czogW01hc2tlZElucHV0RGlyZWN0aXZlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGV4dE1hc2tNb2R1bGUgeyB9XHJcblxyXG5leHBvcnQgeyBjb25mb3JtVG9NYXNrIH0gZnJvbSAndGV4dC1tYXNrLWNvcmUvZGlzdC90ZXh0TWFza0NvcmUnIl19